"""Utilities for translating ORF detection"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import warnings

from collections import Counter
from collections import defaultdict

import datetime
import numpy as np
from tqdm import *
import pandas as pd

from .bam import split_bam
from bx.intervals.intersection import IntervalTree
from .const import CUTOFF
from .const import MINIMUM_VALID_CODONS
from .fasta import FastaReader
from .gtf import GTFReader
from .infer_protocol import infer_protocol
from .metagene import metagene_coverage
from .metagene import align_metagenes
from .orf import ORF
from .plotting import plot_read_lengths
from .plotting import plot_metagene
from .prepare_orfs import prepare_orfs
from .statistics import coherence


def parse_ribocop_index(ribocop_index):
    """
    Parameters
    ----------
    ribocop_index: str
                   Path to the index file generated by RiboCop prepare_orfs

    Returns
    -------
    annotated: List[ORF]
               ORFs of CDS annotated
    novel: List[ORF]
           list of non-annotated ORFs
    refseq: defaultdict(IntervalTree)
            chrom: (start, end, strand)
    """

    annotated = []
    refseq = defaultdict(IntervalTree)

    # print('parsing candidate ORFs...')
    total_lines = 0
    with open(ribocop_index, 'r') as anno:
        for line in anno:
            if 'annotated' in anno:
                total_lines += 1
            else:
                break
    with open(ribocop_index, 'r') as anno:
        with tqdm(total=total_lines) as pbar:
            header = True
            for line in anno:
                pbar.update()
                if header:
                    header = False
                    continue
                orf = ORF.from_string(line)
                if orf is None:
                    continue
                if orf.category == 'annotated':
                    refseq[orf.chrom].insert(orf.intervals[0].start,
                                             orf.intervals[-1].end, orf.strand)
                    annotated.append(orf)
                else:
                    break
    return (annotated, refseq)


def orf_coverage(orf, alignments, offset_5p=0, offset_3p=0):
    """
    Parameters
    ----------
    orf: ORF
         instance of ORF
    alignments: dict(Counter)
                alignments summarized from bam by merging lengths
    offset_5p: int
               the number of nts to include from 5'prime
    offset_3p: int
               the number of nts to include from 3'prime

    Returns
    -------
    coverage: array
              coverage for ORF
    """
    coverage = []
    chrom = orf.chrom
    strand = orf.strand
    if strand == '-':
        offset_5p, offset_3p = offset_3p, offset_5p
    first, last = orf.intervals[0], orf.intervals[-1]
    for pos in range(first.start - offset_5p, first.start):
        if orf.category == 'annotated':
            try:
                coverage.append(alignments[strand][(chrom, pos)])
            except KeyError:
                coverage.append(0)
        else:
            if strand in alignments and (chrom, pos) in alignments[strand]:
                coverage.append(alignments[strand][(chrom, pos)])
            else:
                coverage.append(0)

    for iv in orf.intervals:
        for pos in range(iv.start, iv.end + 1):
            if orf.category == 'annotated':
                try:
                    coverage.append(alignments[strand][(chrom, pos)])
                except KeyError:
                    coverage.append(0)
            else:
                if strand in alignments and (chrom, pos) in alignments[strand]:
                    coverage.append(alignments[strand][(chrom, pos)])
                else:
                    coverage.append(0)

    for pos in range(last.end + 1, last.end + offset_3p + 1):
        if orf.category == 'annotated':
            try:
                coverage.append(alignments[strand][(chrom, pos)])
            except KeyError:
                coverage.append(0)
        else:
            if strand in alignments and (chrom, pos) in alignments[strand]:
                coverage.append(alignments[strand][(chrom, pos)])
            else:
                coverage.append(0)

    if strand == '-':
        coverage.reverse()
    return coverage


def count_orf_reads(ribocop_index,
                    detected_orfs,
                    features,
                    prefix,
                    report_all=False):
    """
    Parameters
    ----------
    ribocop_index: str
                   Path to the index file generated by RiboCop prepare_orfs
    detected_orfs: str
                   Path to the detected orfs file generated by RiboCop detect_orfs
    features: set
              set of ORF types, such as {annotated}
    prefix: str
            prefix for output file
    report_all: bool
                if True, all coverages will be exported
    """
    # print('exporting coverages for all ORFs...')
    columns = [
        'ORF_ID', 'ORF_type', 'status', 'phase_score', 'read_count', 'length',
        'valid_codons', 'transcript_id', 'transcript_type', 'gene_id',
        'gene_name', 'gene_type', 'chrom', 'strand', 'start_codon', 'profile\n'
    ]
    to_write = '\t'.join(columns)
    formatter = '{}\t' * (len(columns) - 1) + '{}\n'
    with open(ribocop_index, 'r') as anno:
        total_lines = len(['' for line in anno])

    with open(ribocop_index, 'r') as anno, open(
            '{}_translating_ORFs.tsv'.format(prefix), 'w') as output:
        with tqdm(total=total_lines) as pbar:
            header = True
            for line in anno:
                pbar.update()
                if header:
                    header = False
                    output.write(to_write)
                    continue
                orf = ORF.from_string(line)
                cov = orf_coverage(orf, merged_alignments)
                count = sum(cov)
                length = len(cov)
                coh, valid = coherence(cov)
                status = 'translating' if (
                    coh >= CUTOFF
                    and valid >= MINIMUM_VALID_CODONS) else 'nontranslating'
                # skip outputing nontranslating ones
                if not report_all and status == 'nontranslating':
                    continue
                to_write = formatter.format(
                    orf.oid, orf.category, status, coh, count, length, valid,
                    orf.tid, orf.ttype, orf.gid, orf.gname, orf.gtype,
                    orf.chrom, orf.strand, orf.start_codon, cov)
                output.write(to_write)
